""" Base Class For Parsing Series ModVal Data """__all__ = ["ParseSeriesDataIO"]from dbbase import MusicDBRootDataIOfrom utils import Timestatfrom pandas import Seriesfrom .parsedataiobase import ParseDataIOBasefrom .parsestats import ParseStatsfrom .parsefiletype import ParseFileType################################################################################ Series Parser###############################################################################class ParseSeriesDataIO(ParseDataIOBase):    def __repr__(self):        return f"ParseSeriesDataIO(db={self.dataio.db})"            def __init__(self, rdio: MusicDBRootDataIO, rawio, parseType: ParseFileType, **kwargs):        super().__init__(rdio, rawio, **kwargs)        self.parseType = parseType                if self.verbose:            print(f"  {'ParseSeriesDataIO:': <25} [{parseType.inputName}] => [{parseType.outputName}]")        def parse(self, **kwargs) -> 'None':        verbose = kwargs.get('verbose', self.verbose)        force = kwargs.get('force', False)        test = kwargs.get('test', False)        force = True if test is True else force        inputSeries = self.pdfio.rdio.getData(self.parseType.inputName)        assert isinstance(inputSeries, Series), "Input is not a Series in ParseSeriesDataIO()"                    rawParser = self.getRawParser(self.parseType)        pstats = ParseStats(name=self.parseType.inputName)            ts = Timestat(f"Parsing {self.db} [Raw Series] => [ModVal {self.parseType.outputName}]", verbose=verbose)        inputSeries.index = inputSeries.index.map(lambda artistID: (artistID, self.mv.getModVal(artistID)))        for n, (modVal, modValGroupData) in enumerate(inputSeries.groupby(axis=0, level=1)):            if self.isUpdateModVal(n):                ts.update(n=n + 1)            if modValGroupData.shape[0] == 0:                continue            modValGroupData = modValGroupData.droplevel(1)                parseStats = {}            self.pdfio.getInput(modVal, self.parseType, parseStats=parseStats, force=force)            parseStats.update({"Good": 0, "Bad": 0})            for fid, fdata in modValGroupData.items():                rData = rawParser(fid, fdata, ifile=None)                status = self.pdfio.updateModValData(rData, self.parseType)                if status is True:                    pstats.addGood()                else:                    pstats.addBad()            self.pdfio.getEndStats(pstats)            if pstats.good == 0:                if verbose:                    print(f"  ==> Not Saving {self.parseType.outputName} ModVal={modVal} Data Because There Is No Good Data.")                return                        ##############################            # Save Output            ##############################            if test is True:                print("  ==> [{pstats.showBasic()}] Only testing. Will not save.")            else:                self.pdfio.saveOutput(modVal, self.parseType, pstats, force=force)                                    ts.stop()