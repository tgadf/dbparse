""" Base Class For Media Utils """__all__ = ["MediaUtilsBase"]from dbraw import RawDataIOBasefrom utils import assertTypeimport warnings################################################################################ ModVal Data Classes###############################################################################class MediaUtilsBase:    def __repr__(self):        return "MediaUtilsBase()"        def __init__(self, mediaTypes, mediaTypeData, mediaTypeIDReqs):        self.rdbio = RawDataIOBase()        self.mediaTypes = mediaTypes        self.mediaTypeData = mediaTypeData        self.mediaTypeIDReqs = mediaTypeIDReqs        assert isinstance(self.mediaTypes, list), f"MediaTypeData [{type(self.mediaTypes)}] is not a dict"        assert isinstance(self.mediaTypeData, dict), f"MediaTypeData [{type(self.mediaTypeData)}] is not a dict"        assert isinstance(self.mediaTypeIDReqs, dict), f"mediaTypeIDReqs [{type(self.mediaTypeIDReqs)}] is not a dict"        self.known = {}        def getPanDBID(self, mediaTypeName, artistID=None, albumID=None, trackID=None) -> 'str':        mediaTypeIDReqs = self.mediaTypeIDReqs.get(mediaTypeName)        if not isinstance(mediaTypeIDReqs, list):            if self.known.get(mediaTypeName) is None:                print(f"\"{mediaTypeName}\",")                self.known[mediaTypeName] = True            mediaTypeIDReqs = ["Artist", "Album"]        assert isinstance(mediaTypeIDReqs, list), f"MediaType [{mediaTypeName}] does not have ID Req"                reqs = []        if "Artist" in mediaTypeIDReqs:            if isinstance(artistID, str):                reqs.append(f"Art{artistID}")        if "Album" in mediaTypeIDReqs:            if isinstance(albumID, str):                reqs.append(f"Alb{albumID}")        if "Track" in mediaTypeIDReqs:            if isinstance(trackID, str):                reqs.append(f"Trk{trackID}")        assert len(reqs) > 0, f"No reqs defined: [{mediaTypeIDReqs}]"        assert assertType(reqs, str), f"Not all values are str: {reqs}"                retval = "-".join([mediaTypeName] + reqs)        return retval    def compareMedia(self, mediaOld, mediaNew) -> 'bool':        if all([self.rdbio.isRawMediaRootData(obj) for obj in [mediaOld, mediaNew]]):            if mediaOld.get() == mediaNew.get():                return True                        retval = False if self.unique is True else True            return retval        elif all([self.rdbio.isRawMediaDeepData(obj) for obj in [mediaOld, mediaNew]]):            if mediaOld.get() == mediaNew.get():                return True                            mediaTypeName = mediaOld.group            assert mediaTypeName in self.mediaTypes, f"MediaTypeName [{mediaTypeName}] not in allowed list {self.mediaTypes}"            compareKeys = self.mediaTypeData.get(mediaTypeName)            if not isinstance(compareKeys, list):                warnings.warn(f"| Could not find [{mediaTypeName}] in available keys: {self.mediaTypeData.keys()}")                warnings.warn(f"|    Old Media: {mediaOld.get()}")                warnings.warn(f"|    New Media: {mediaNew.get()}")                warnings.warn("|    Returning True ... ")                return True            mediaOldCompareDict = {k: v for k, v in mediaOld.get().items() if k in compareKeys}            mediaNewCompareDict = {k: v for k, v in mediaNew.get().items() if k in compareKeys}            if mediaOldCompareDict == mediaNewCompareDict:                return True                        retval = False if self.unique is True else True            return retval                raise ValueError(f"Can't compare old and new media of type [{type(mediaOld)} / {type(mediaNew)}]")