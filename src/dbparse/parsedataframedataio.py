""" Base Class For Parsing DataFrame ModVal Data """__all__ = ["ParseDataFrameDataIO"]from dbbase import MusicDBRootDataIOfrom utils import Timestatfrom pandas import DataFrameimport warningsfrom .parsedataiobase import ParseDataIOBasefrom .parsestats import ParseStatsfrom .parsefiletype import ParseFileType################################################################################ DataFrame Parser###############################################################################class ParseDataFrameDataIO(ParseDataIOBase):    def __repr__(self):        return f"ParseDataFrameDataIO(db={self.dataio.db})"            def __init__(self, rdio: MusicDBRootDataIO, rawio, parseType: ParseFileType, **kwargs):        super().__init__(rdio, rawio, **kwargs)        assert isinstance(parseType, ParseFileType), f"parseType [{parseType}] is not a ParseFileType"        self.parseType = parseType                if self.verbose:            print(f"  {'ParseDataFrameDataIO:': <25} [{parseType.inputName}] => [{parseType.outputName}]")                    def parse(self, **kwargs) -> 'None':        verbose = kwargs.get('verbose', self.verbose)        force = kwargs.get('force', True)        test = kwargs.get('test', False)        force = True if test is True else force        inputDataFrame = self.pdfio.rdio.getData(self.parseType.inputName)        assert isinstance(inputDataFrame, DataFrame), "Input is not a DataFrame in ParseDataFrameDataIO()"                if "ModVal" not in inputDataFrame.columns:            warnings.warn("ModVal column not found. Creating it from index.")            inputDataFrame["ModVal"] = inputDataFrame.index.map(self.mv.getModVal)                rawParser = self.getRawParser(self.parseType)        pstats = ParseStats(name=self.parseType.inputName)                tscmt = f"Parsing {self.db} [Raw {self.parseType.inputName}] => [ModVal {self.parseType.outputName}]"        ts = Timestat(tscmt, verbose=verbose)        for n, (modVal, modValGroupData) in enumerate(inputDataFrame.groupby("ModVal")):            if self.isUpdateModVal(n):                ts.update(n=n + 1)            parseStats = {}            self.pdfio.getInput(modVal, self.parseType, parseStats=parseStats, force=force)            parseStats.update({"Good": 0, "Bad": 0})            for i, (fid, fdata) in enumerate(modValGroupData.iterrows()):                if test is True and i > 10:                    break                                rData = rawParser(fid, fdata, ifile=None)                status = self.pdfio.updateModValData(rData, self.parseType)                if status is True:                    pstats.addGood()                else:                    pstats.addBad()            self.pdfio.getEndStats(pstats)            if pstats.good == 0:                if verbose:                    print(f"  ==> Not Saving {self.parseType.outputName} ModVal={modVal} Data Because There Is No Good Data.")                return                        ##############################            # Save Output            ##############################            if test is True:                print("  ==> [{pstats.showBasic()}] Only testing. Will not save.")            else:                self.pdfio.saveOutput(modVal, self.parseType, pstats, force=force)                                    ts.stop()